{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es6.function.bind.js","webpack:///./node_modules/core-js/modules/_bind.js","webpack:///./node_modules/css-doodle/css-doodle.js"],"names":["$export","__webpack_require__","P","bind","aFunction","isObject","invoke","arraySlice","slice","factories","module","exports","Function","that","fn","this","partArgs","call","arguments","bound","args","concat","F","len","n","i","join","construct","length","prototype","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","iterator","input","index","col","line","curr","end","info","[object Object]","next","parse_var","trim","result","test","it","word","marks","groups","c","push","name","alternative","Error","pop","parse","e","console","error","message","make_array","arr","Array","isArray","spliter","last","first","flat_map","flatMap","reduce","acc","x","Tokens","func","type","argument","value","text","pseudo","selector","styles","cond","rule","property","keyframes","steps","step","is","white_space","line_break","number","isNaN","pair","includes","pair_of","\"","'","(","throw_error","msg","read_until","reset","read_word","read_keyframe_name","read_line","read_step","extra","read_rule","read_selector","read_steps","read_keyframes","read_comments","flag","inline","read_property","prop","read_arguments","group","stack","arg","trimLeft","read_func","normalize_argument","map","String","replace","ft","ed","cf","ce","split","unshift","position","read_value","idx","skip","read_cond_selector","read_pseudo","read_var","read_cond","Object","assign","read_property_value","get_custom_property_value","ret","evaluate_value","values","forEach","v","vars","p","parsed","other","every","parse$1","apply","token","apply_args","f","clamp","num","min","max","Math","range","start","stop","count","old","initial","is_letter","lazy","wrap","sequence","total","parse_grid","size","y","z","Number","max_val","create_svg_url","svg","id","blob","Blob","url","URL","createObjectURL","encoded","encodeURIComponent","normalize_svg","xmlns","rand","t","lerp","random","by_unit","unit","some","str","matched","match","get_unit","restore","by_charcode","codes","charCodeAt","fromCharCode","calc","expr","tokens","operator","get_tokens","op_stack","op","infix_to_postfix","top","shift","right","left","compute","*","/","%","+","-",")","a","b","store","memo$1","prefix","key","expand","startsWith","build_range","Type","endsWith","from","get_tokens$1","to","reverse","cos","sin","sqrt","pow","PI","DEG","polygon","option","scale","deg","points","rotate","rad","shapes","circle","triangle","rhombus","pentagon","hexgon","hexagon","heptagon","octagon","star","diamond","cross","clover","k","m","astroid","hypocycloid","infinity","heart","bean","bicorn","pear","fish","whale","r","bud","d","obj","names","Func","_","row","grid","size-row","size-col","pick","context","last_pick","items","counter","pos","shuffle","last-pick","multiple","action","multitple-with-space","repeat","transform_type","last_rand","rand-int","parseInt","last-rand","hex","toString","svg-filter","substr","unique_id","var","shape","memo","multi","ms","pn","pd","ri","lp","lr","pick-by-turn","max-row","max-col","keys","is_seperator","skip_seperator","parse$2","all","get_props","props","Set","document","head","style","add","toLowerCase","has","filter","build_mapping","reg","RegExp","props_webkit_mapping","props_moz_mapping","prefixer","Property","is_special_selector","w","h","@place-cell","map_left_right","center","0","bottom","map_top_bottom","cw","ch","options","s","@shape","rules","nth","build_expr","is$1","even","odd","even_or_odd","Selector","at","x1","y1","exprs","ratio","MathFunc","getOwnPropertyNames","expose","is_host_selector","is_parent_selector","Rules","coords","host","container","cells","pick_func","compose_argument","val","fname","_coords","value_group","composed","compose_value","has_animation","compose_aname","has_transition","transformed","compose","add_rule","compose_selector","compose_rule","special","target","aname","maybe","generator","grid_size","output","customElements","define","HTMLElement","super","doodle","attachShadow","mode","setTimeout","compiled","use","getAttribute","innerHTML","build_grid","getComputedStyle","getPropertyValue","style_basic","style_size","html_cells","set_style","inherit_props","block","depth","el","shadowRoot","querySelector","styleSheet","cssText","gx","gy","gz","setAttribute","connectedCallback","observedAttributes","old_val","new_val"],"mappings":"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","file":"8-2822e74d1ccfad097951.js","sourcesContent":["// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = require('./_export');\n\n$export($export.P, 'Function', { bind: require('./_bind') });\n","'use strict';\nvar aFunction = require('./_a-function');\nvar isObject = require('./_is-object');\nvar invoke = require('./_invoke');\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n","(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) :\n  factory();\n}(function () { 'use strict';\n\n  function iterator(input) {\n    let index = 0, col = 1, line = 1;\n    return {\n      curr(n = 0) {\n        return input[index + n];\n      },\n      end() {\n        return input.length <= index;\n      },\n      info() {\n        return { index, col, line };\n      },\n      index(n) {\n        return (n === undefined ? index : index = n);\n      },\n      next() {\n        let next = input[index++];\n        if (next == '\\n') line++, col = 0;\n        else col++;\n        return next;\n      }\n    };\n  }\n\n  // I'll make it work first\n  function parse(it) {\n    let word = '', marks = [];\n    let groups = [], result = {};\n\n    while(!it.end()) {\n      let c = it.curr();\n      if (c == '(') {\n        marks.push(c);\n        word = '';\n      }\n      else if (c == ')' || c == ',') {\n        if (/^\\-\\-.+/.test(word)) {\n          if (!result.name) {\n            result.name = word;\n          } else {\n            if (!result.alternative) {\n              result.alternative = [];\n            }\n            result.alternative.push({\n              name: word\n            });\n          }\n        }\n\n        if (c == ')') {\n          if (marks[marks.length - 1] == '(') {\n            marks.pop();\n          } else {\n            throw new Error('bad match');\n          }\n        }\n\n        if (c == ',') {\n          if (!marks.length) {\n            groups.push(result);\n            result = {};\n          }\n        }\n\n        word = '';\n      }\n      else if (!/\\s/.test(c)) {\n        word += c;\n      }\n      it.next();\n    }\n\n    if (marks.length) {\n      return [];\n    }\n\n    if (result.name) {\n      groups.push(result);\n    }\n    return groups;\n  }\n\n  function parse_var(input) {\n    input = input.trim();\n    let result = [];\n    if (!/^var\\(/.test(input)) {\n      return result;\n    }\n    let it = iterator(input);\n    try {\n      result = parse(it);\n    } catch (e) {\n      console.error(e && e.message || 'Bad variables.');\n    }\n    return result;\n  }\n\n  function make_array(arr) {\n    return Array.isArray(arr) ? arr : [arr];\n  }\n\n  function join(arr, spliter = '\\n') {\n    return (arr || []).join(spliter);\n  }\n\n  function last(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function first(arr) {\n    return arr[0];\n  }\n\n  function shuffle(arr) {\n    let ret = Array.from ? Array.from(arr) : arr.slice();\n    let m = arr.length;\n    while (m) {\n      let i = ~~(Math.random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n\n  function flat_map(arr, fn) {\n    if (Array.prototype.flatMap) return arr.flatMap(fn);\n    return arr.reduce((acc, x) => acc.concat(fn(x)), []);\n  }\n\n  const Tokens = {\n    func(name = '') {\n      return {\n        type: 'func',\n        name,\n        arguments: []\n      };\n    },\n    argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n    text(value = '') {\n      return {\n        type: 'text',\n        value\n      };\n    },\n    pseudo(selector = '') {\n      return {\n        type: 'pseudo',\n        selector,\n        styles: []\n      };\n    },\n    cond(name = '') {\n      return {\n        type: 'cond',\n        name,\n        styles: [],\n        arguments: []\n      };\n    },\n    rule(property = '') {\n      return {\n        type: 'rule',\n        property,\n        value: []\n      };\n    },\n    keyframes(name = '') {\n      return {\n        type: 'keyframes',\n        name,\n        steps: []\n      }\n    },\n\n    step(name = '') {\n      return {\n        type: 'step',\n        name,\n        styles: []\n      }\n    }\n  };\n\n  const is = {\n    white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n    line_break(c) {\n      return /\\n/.test(c);\n    },\n    number(n) {\n      return !isNaN(n);\n    },\n    pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n    pair_of(c, n) {\n      return ({ '\"': '\"', \"'\": \"'\", '(': ')' })[c] == n;\n    }\n  };\n\n  function throw_error(msg, { col, line }) {\n    console.error(\n      `(at line ${ line }, column ${ col }) ${ msg }`\n    );\n  }\n\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim()\n    } else {\n      return input;\n    }\n  }\n\n  function read_until(fn) {\n    return function(it, reset) {\n      let index = it.index();\n      let word = '';\n      while (!it.end()) {\n        let c = it.next();\n        if (fn(c)) break;\n        else word += c;\n      }\n      if (reset) {\n        it.index(index);\n      }\n      return word;\n    }\n  }\n\n  function read_word(it, reset) {\n    let check = c => /[^\\w@]/.test(c);\n    return read_until(check)(it, reset);\n  }\n\n  function read_keyframe_name(it) {\n    return read_until(c => /[\\s\\{]/.test(c))(it);\n  }\n\n  function read_line(it, reset) {\n    let check = c => is.line_break(c) || c == '{';\n    return read_until(check)(it, reset);\n  }\n\n  function read_step(it, extra) {\n    let c, step = Tokens.step();\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!step.name.length) {\n        step.name = read_selector(it);\n      }\n      else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return step;\n  }\n\n  function read_steps(it, extra) {\n    const steps = [];\n    let c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n    return steps;\n  }\n\n  function read_keyframes(it, extra) {\n    let keyframes = Tokens.keyframes(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n        continue;\n      }\n      else if (c == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n    return keyframes;\n  }\n\n  function read_comments(it, flag = {}) {\n    it.next();\n    while (!it.end()) {\n      let c = it.curr();\n      if (flag.inline) {\n        if (c == '\\n') break;\n      }\n      else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n      it.next();\n    }\n    if (!flag.inline) {\n      it.next(); it.next();\n    }\n  }\n\n  function read_property(it) {\n    let prop = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;\n      else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n    return prop;\n  }\n\n  function read_arguments(it) {\n    let args = [], group = [], stack = [], arg = '', c;\n    while (!it.end()) {\n      c = it.curr();\n\n      if ((/[\\('\"`]/.test(c) && it.curr(-1) !== '\\\\')) {\n        if (stack.length) {\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n        arg += c;\n      }\n      else if (c == '@') {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n        group.push(read_func(it));\n      }\n      else if (/[,)]/.test(c)) {\n        if (stack.length) {\n          if (c == ')') {\n            stack.pop();\n          }\n          arg += c;\n        }\n\n        else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else {\n              if (arg.length) {\n                group.push(Tokens.text(arg));\n              }\n            }\n          }\n\n          args.push(normalize_argument(group));\n          [group, arg] = [[], ''];\n\n          if (c == ')') break;\n        }\n      }\n      else {\n        arg += c;\n      }\n      it.next();\n    }\n    return args;\n  }\n\n  function normalize_argument(group) {\n    let result = group.map(arg => {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        let value = String(arg.value);\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n        arg.value = value.replace(/\\n+|\\s+/g, ' ');\n      }\n      return arg;\n    });\n\n    let ft = first(result) || {};\n    let ed = last(result) || {};\n    if (ft.type == 'text' && ed.type == 'text') {\n      let cf = first(ft.value);\n      let ce  = last(ed.value);\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair(cf) && is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n        }\n      }\n    }\n    return result;\n  }\n\n  function read_func(it) {\n    let func = Tokens.func();\n    let extra = '', name = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ')') break;\n      if (c == '(') {\n        it.next();\n        func.name = name;\n        func.arguments = read_arguments(it);\n        if (/\\d$/.test(name)) {\n          func.name = name.split(/\\d+/)[0];\n          extra = name.split(/\\D+/)[1];\n        }\n        if (extra.length) {\n          func.arguments.unshift([{\n            type: 'text',\n            value: extra\n          }]);\n        }\n        func.position = it.info().index;\n        break;\n      }\n      else name += c;\n      it.next();\n    }\n    return func;\n  }\n\n  function read_value(it) {\n    let text = Tokens.text(), idx = 0, skip = true, c;\n    const value = [], stack = [];\n    value[idx] = [];\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      }\n      else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[++idx] = [];\n        skip = true;\n      }\n      else if (/[;}]/.test(c)) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        break;\n      }\n      else if (c == '@') {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[idx].push(read_func(it));\n      }\n      else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n        text.value += c;\n      }\n      it.next();\n    }\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n    return value;\n  }\n\n  function read_selector(it) {\n    let selector = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;\n      else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_cond_selector(it) {\n    let selector = { name: '', arguments: [] }, c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it);\n      }\n      else if (/[){]/.test(c)) break;\n      else if (!is.white_space(c)) selector.name += c;\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_pseudo(it, extra) {\n    let pseudo = Tokens.pseudo(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      }\n      else {\n        let rule = read_rule(it, extra);\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(\n            rule.value\n          );\n        } else {\n          pseudo.styles.push(rule);\n        }\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return pseudo;\n  }\n\n  function read_rule(it, extra) {\n    let rule = Tokens.rule(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ';') break;\n      else if (!rule.property.length) {\n        rule.property = read_property(it);\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      }\n      else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n    return rule;\n  }\n\n  function read_cond(it, extra) {\n    let cond = Tokens.cond(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return cond;\n  }\n\n  function read_property_value(extra, name) {\n    let rule = '';\n    if (extra && extra.get_custom_property_value) {\n      rule = extra.get_custom_property_value(name);\n    }\n    return rule;\n  }\n\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(v => {\n      if (v.type == 'text' && v.value) {\n        let vars = parse_var(v.value);\n        v.value = vars.reduce((ret, p) => {\n          let rule = '', other = '', parsed;\n          rule = read_property_value(extra, p.name);\n          if (!rule && p.alternative) {\n            p.alternative.every(n => {\n              other = read_property_value(extra, n.name);\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n          try {\n            parsed = parse$1(rule, extra);\n          } catch (e) { }\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n          return ret;\n        }, []);\n      }\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(arg => {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n\n  function read_var(it, extra) {\n    it.next();\n    let groups = read_value(it) || [];\n    return groups.reduce((ret, group) => {\n      evaluate_value(group, extra);\n      let [token] = group;\n      if (token.value && token.value.length) {\n        ret.push(...token.value);\n      }\n      return ret;\n    }, []);\n  }\n\n  function parse$1(input, extra) {\n    const it = iterator(input);\n    const Tokens = [];\n    while (!it.end()) {\n      let c = it.curr();\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      }\n      else if (c == '/' && it.curr(1) == '/') {\n        read_comments(it, { inline: true });\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      }\n      else if (c == '@' && read_word(it, true) === '@keyframes') {\n        let keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        let cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n      it.next();\n    }\n    return Tokens;\n  }\n\n  function apply_args(fn, ...args) {\n    return args.reduce((f, arg) =>\n      f.apply(null, make_array(arg)), fn\n    );\n  }\n\n  function clamp(num, min, max) {\n    return Math.max(min, Math.min(max, num));\n  }\n\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return (typeof value === 'function') ? value() : value;\n  }\n\n  function range(start, stop, step) {\n    let count = 0, old = start;\n    let initial = n => (n > 0 && n < 1) ? .1 : 1;\n    let length = arguments.length;\n    if (length == 1) [start, stop] = [initial(start), start];\n    if (length < 3) step = initial(start);\n    let range = [];\n    while ((step >= 0 && start <= stop)\n      || (step < 0 && start > stop)) {\n      range.push(start);\n      start += step;\n      if (count++ >= 1000) break;\n    }\n    if (!range.length) range.push(old);\n    return range;\n  }\n\n  function alias_for(obj, names) {\n    Object.keys(names).forEach(n => {\n      obj[n] = obj[names[n]];\n    });\n    return obj;\n  }\n\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n\n  function lazy(fn) {\n    let wrap = () => fn;\n    wrap.lazy = true;\n    return wrap;\n  }\n\n  function sequence(count, fn) {\n    let ret = [];\n    for (let i = 0; i < count; ++i) {\n      ret.push(fn(i));\n    }\n    return ret;\n  }\n\n  const [ min, max, total ] = [ 1, 32, 32 * 32 ];\n\n  function parse_grid(size) {\n    let [x, y, z] = (size + '')\n      .replace(/\\s+/g, '')\n      .replace(/[,，xX]+/g, 'x')\n      .split('x')\n      .map(Number);\n\n    const max_val = (x == 1 || y == 1) ? total : max;\n\n    const ret = {\n      x: clamp(x || min, 1, max_val),\n      y: clamp(y || x || min, 1, max_val),\n      z: clamp(z || min, 1, max_val)\n    };\n\n    return Object.assign({}, ret,\n      { count: ret.x * ret.y }\n    );\n  }\n\n  function create_svg_url(svg, id) {\n    if (id) {\n      let blob = new Blob([svg], { type: 'image/svg+xml' });\n      let url = URL.createObjectURL(blob);\n      return `url(${ url }#${ id })`;\n    }\n    else {\n      let encoded = encodeURIComponent(svg);\n      return `url(\"data:image/svg+xml;utf8,${ encoded }\")`;\n    }\n  }\n\n  function normalize_svg(input) {\n    const xmlns = 'xmlns=\"http://www.w3.org/2000/svg\"';\n    if (!input.includes('<svg')) {\n      input = `<svg ${ xmlns }>${ input }</svg>`;\n    }\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, `<svg ${ xmlns }$1`);\n    }\n    return input;\n  }\n\n  function lerp(start, end, t) {\n    return start * (1 - t) + end * t;\n  }\n\n  function rand(start = 0, end = start) {\n    if (arguments.length == 1) {\n      start = start < 1 ? .1 : 1;\n    }\n    return lerp(start, end, Math.random());\n  }\n\n  function pick(...items) {\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(Math.random() * args.length)];\n  }\n\n  function unique_id(prefix = '') {\n    return prefix + Math.random().toString(32).substr(2);\n  }\n\n  function by_unit(fn) {\n    return (...args) => {\n      let unit = get_unit(args);\n      return restore(fn, unit).apply(null, args);\n    }\n  }\n\n  function restore(fn, unit) {\n    return (...args) => {\n      args = args.map(str => Number(\n        String(str).replace(/\\D+$/g, '')\n      ));\n      let result = fn.apply(null, args);\n      if (!unit.length) {\n        return result;\n      }\n      if (Array.isArray(result)) {\n        return result.map(n => n + unit);\n      }\n      return result + unit;\n    }\n  }\n\n  function get_unit(values) {\n    let unit = '';\n    values.some(str => {\n      let input = String(str).trim();\n      if (!input) return '';\n      let matched = input.match(/\\d(\\D+)$/);\n      return (unit = matched ? matched[1] : '');\n    });\n    return unit;\n  }\n\n  function by_charcode(fn) {\n    return (...args) => {\n      let codes = args.map(n => String(n).charCodeAt(0));\n      let result = fn.apply(null, codes);\n      return Array.isArray(result)\n        ? result.map(n => String.fromCharCode(n))\n        : String.fromCharCode(result);\n    }\n  }\n\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n\n  function calc(input) {\n    const expr = infix_to_postfix(input), stack = [];\n    while (expr.length) {\n      let top = expr.shift();\n      if (/\\d+/.test(top)) stack.push(top);\n      else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(\n          top, Number(left), Number(right)\n        ));\n      }\n    }\n    return stack[0];\n  }\n\n  const operator = {\n    '*': 3, '/': 3, '%': 3,\n    '+': 2, '-': 2,\n    '(': 1, ')': 1\n  };\n\n  function get_tokens(input) {\n    let expr = String(input);\n    let tokens = [], num = '';\n\n    for (let i = 0; i < expr.length; ++i) {\n      let c = expr[i];\n\n      if (operator[c]) {\n        if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        }\n        else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          let { type, value } = last(tokens) || {};\n          if (type == 'operator'\n              && !num.length\n              && /[^()]/.test(c)\n              && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({ type: 'number', value: num });\n              num = '';\n            }\n            tokens.push({ type: 'operator', value: c });\n          }\n        }\n      }\n\n      else if (/\\S/.test(c)) {\n        num += c;\n      }\n    }\n\n    if (num.length) {\n      tokens.push({ type: 'number', value: num });\n    }\n\n    return tokens;\n  }\n\n  function infix_to_postfix(input) {\n    let tokens = get_tokens(input);\n    const op_stack = [], expr = [];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      let { type, value } = tokens[i];\n      if (type == 'number') {\n        expr.push(value);\n      }\n\n      else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        }\n\n        else if (value == ')') {\n          while (op_stack.length && last(op_stack) != '(') {\n            expr.push(op_stack.pop());\n          }\n          op_stack.pop();\n        }\n\n        else {\n          while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n            let op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push(op);\n          }\n          op_stack.push(value);\n        }\n      }\n    }\n\n    while (op_stack.length) {\n      expr.push(op_stack.pop());\n    }\n\n    return expr;\n  }\n\n  function compute(op, a, b) {\n    switch (op) {\n      case '+': return a + b;\n      case '-': return a - b;\n      case '*': return a * b;\n      case '/': return a / b;\n      case '%': return a % b;\n    }\n  }\n\n  const store = {};\n\n  function memo$1(prefix, fn) {\n    return (...args) => {\n      let key = prefix + args.join('-');\n      if (store[key]) return store[key];\n      return (store[key] = fn.apply(null, args));\n    }\n  }\n\n  function expand(fn) {\n    return (...args) => fn.apply(null, flat_map(args, n =>\n      String(n).startsWith('[') ? build_range(n) : n\n    ));\n  }\n\n  function Type(type, value) {\n    return { type, value };\n  }\n\n  function get_tokens$1(input) {\n    let expr = String(input);\n    let tokens = [], stack = [];\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n\n    for (let i = 1; i < expr.length - 1; ++i) {\n      let c = expr[i];\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n      if (last(stack) == '-') {\n        stack.pop();\n        let from = stack.pop();\n        tokens.push(from\n          ? Type('range', [ from, c ])\n          : Type('char', c)\n        );\n        continue;\n      }\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n      stack.push(c);\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    return tokens;\n  }\n\n  const build_range = memo$1('build_range', (input) => {\n    let tokens = get_tokens$1(input);\n    return flat_map(tokens, ({ type, value }) => {\n      if (type == 'char') return value;\n      let [ from, to ] = value;\n      let reverse = false;\n      if (from > to) {\n        [from, to] = [ to, from ];\n        reverse = true;\n      }\n      let result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n\n  const { cos, sin, sqrt, pow, PI } = Math;\n  const DEG = PI / 180;\n\n  function polygon(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n\n    if (!fn) {\n      fn = t => [ cos(t), sin(t) ];\n    }\n\n    let split = option.split || 120;\n    let scale = option.scale || 1;\n    let start = DEG * (option.start || 0);\n    let deg = option.deg ? (option.deg * DEG) : (PI / (split / 2));\n    let points = [];\n\n    for (let i = 0; i < split; ++i) {\n      let t = start + deg * i;\n      let [x, y] = fn(t);\n      points.push(\n        ((x * 50 * scale) + 50 + '% ') +\n        ((y * 50 * scale) + 50 + '%')\n      );\n    }\n\n    return option.type\n      ? `polygon(${ option.type }, ${ points.join(',') })`\n      : `polygon(${ points.join(',') })`;\n  }\n\n  function rotate(x, y, deg) {\n    let rad = DEG * deg;\n    return [\n      x * cos(rad) - y * sin(rad),\n      y * cos(rad) + x * sin(rad)\n    ];\n  }\n\n  const shapes =  {\n\n    circle() {\n      return 'circle(49%)';\n    },\n\n    triangle() {\n      return polygon({ split: 3, start: -90 }, t => [\n        cos(t) * 1.1,\n        sin(t) * 1.1 + .2\n      ]);\n    },\n\n    rhombus() {\n      return polygon({ split: 4 });\n    },\n\n    pentagon() {\n      return polygon({ split: 5, start: 54 });\n    },\n\n    hexgon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    hexagon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    heptagon() {\n      return polygon({ split: 7, start: -90 });\n    },\n\n    octagon() {\n      return polygon({ split: 8, start: 22.5 });\n    },\n\n    star() {\n      return polygon({ split: 5, start: 54, deg: 144 });\n    },\n\n    diamond() {\n      return 'polygon(50% 5%, 80% 50%, 50% 95%, 20% 50%)';\n    },\n\n    cross() {\n      return `polygon(\n      5% 35%,  35% 35%, 35% 5%,  65% 5%,\n      65% 35%, 95% 35%, 95% 65%, 65% 65%,\n      65% 95%, 35% 95%, 35% 65%, 5% 65%\n    )`;\n    },\n\n    clover(k = 3) {\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return polygon({ split: 240 }, t => {\n        let x = cos(k * t) * cos(t);\n        let y = cos(k * t) * sin(t);\n        if (k == 3) x -= .2;\n        if (k == 2) {\n          x /= 1.1;\n          y /= 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    hypocycloid(k = 3) {\n      k = clamp(k, 3, 6);\n      let m = 1 - k;\n      return polygon({ scale: 1 / k  }, t => {\n        let x = m * cos(t) + cos(m * (t - PI));\n        let y = m * sin(t) + sin(m * (t - PI));\n        if (k == 3) {\n          x = x * 1.1 - .6;\n          y = y * 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    astroid() {\n      return shapes.hypocycloid(4);\n    },\n\n    infinity() {\n      return polygon(t => {\n        let a = .7 * sqrt(2) * cos(t);\n        let b = (pow(sin(t), 2) + 1);\n        return [\n          a / b,\n          a * sin(t) / b\n        ]\n      });\n    },\n\n    heart() {\n      return polygon(t => {\n        let x = .75 * pow(sin(t), 3);\n        let y =\n            cos(1 * t) * (13 / 18)\n          - cos(2 * t) * (5 / 18)\n          - cos(3 * t) / 18\n          - cos(4 * t) / 18;\n        return rotate(\n          x * 1.2,\n          (y + .2) * 1.1,\n          180\n        );\n      });\n    },\n\n    bean() {\n      return polygon(t => {\n        let [a, b] = [pow(sin(t), 3), pow(cos(t), 3)];\n        return rotate(\n          (a + b) * cos(t) * 1.3 - .45,\n          (a + b) * sin(t) * 1.3 - .45,\n          -90\n        );\n      });\n    },\n\n    bicorn() {\n      return polygon(t => rotate(\n        cos(t),\n        pow(sin(t), 2) / (2 + sin(t)) - .5,\n        180\n      ));\n    },\n\n    pear() {\n      return polygon(t => [\n        sin(t),\n        (1 + sin(t)) * cos(t) / 1.4\n      ]);\n    },\n\n    fish() {\n      return polygon(t => [\n        cos(t) - pow(sin(t), 2) / sqrt(2),\n        sin(2 * t) / 2\n      ]);\n    },\n\n    whale() {\n      return polygon({ split: 240 }, t => {\n        let r = 3.4 * (pow(sin(t), 2) - .5) * cos(t);\n        return rotate(\n          cos(t) * r + .75,\n          sin(t) * r * 1.2,\n          180\n        );\n      });\n    },\n\n    bud(n = 3) {\n      n = clamp(n, 3, 10);\n      return polygon({ split: 240 }, t => [\n        ((1 + .2 * cos(n * t)) * cos(t)) * .8,\n        ((1 + .2 * cos(n * t)) * sin(t)) * .8\n      ]);\n    },\n\n    alien(...args) {\n      let [a = 1, b = 1, c = 1, d = 1, e = 1]\n        = args.map(n => clamp(n, 1, 9));\n      return polygon({ split: 480, type: 'evenodd' }, t => [\n        (cos(t * a) + cos(t * c) + cos(t * e)) * .31,\n        (sin(t * b) + sin(t * d) + sin(t)) * .31\n      ]);\n    }\n\n  };\n\n  const Expose = {\n\n    index({ count }) {\n      return _ => count;\n    },\n\n    row({ x }) {\n      return _ => x;\n    },\n\n    col({ y }) {\n      return _ => y;\n    },\n\n    size({ grid }) {\n      return _ => grid.count;\n    },\n\n    ['size-row']({ grid }) {\n      return _ => grid.x;\n    },\n\n    ['size-col']({ grid }) {\n      return _ => grid.y;\n    },\n\n    n({ idx }) {\n      return _ => idx || 0;\n    },\n\n    pick({ context }) {\n      return expand((...args) => (\n        context.last_pick = pick(args)\n      ));\n    },\n\n    ['pick-n']({ idx, context, position }) {\n      let counter = 'pn-counter' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        let max = args.length;\n        let pos = ((idx == undefined ? context[counter] : idx) - 1) % max;\n        return context.last_pick = args[pos];\n      });\n    },\n\n    ['pick-d']({ idx, context, position }) {\n      let counter = 'pd-counter' + position;\n      let values = 'pd-values' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        if (!context[values]) {\n          context[values] = shuffle(args);\n        }\n        let max = args.length;\n        let pos = ((idx == undefined ? context[counter] : idx) - 1) % max;\n        return context.last_pick = context[values][pos];\n      });\n    },\n\n    ['last-pick']({ context }) {\n      return () => context.last_pick;\n    },\n\n    multiple: lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(n(), 0, 65536);\n      return sequence(count, i => action(i + 1)).join(',');\n    }),\n\n    ['multitple-with-space']: lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(n(), 0, 65536);\n      return sequence(count, i => action(i + 1)).join(' ');\n    }),\n\n    repeat: lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(n(), 0, 65536);\n      return sequence(count, i => action(i + 1)).join('');\n    }),\n\n    rand({ context }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter)\n          ? by_charcode\n          : by_unit;\n        let value = transform_type(rand).apply(null, args);\n        return context.last_rand = value;\n      };\n    },\n\n    ['rand-int']({ context }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter)\n          ? by_charcode\n          : by_unit;\n        let value = parseInt(\n          transform_type(rand).apply(null, args)\n        );\n        return context.last_rand = value;\n      }\n    },\n\n    ['last-rand']({ context }) {\n      return () => context.last_rand;\n    },\n\n    calc() {\n      return value => calc(value);\n    },\n\n    hex() {\n      return value => parseInt(value).toString(16);\n    },\n\n    svg: lazy(input => {\n      if (input === undefined) return '';\n      let svg = normalize_svg(input().trim());\n      return create_svg_url(svg);\n    }),\n\n    ['svg-filter']: lazy(input => {\n      if (input === undefined) return '';\n      let id = unique_id('filter-');\n      let svg = normalize_svg(input().trim())\n        .replace(\n          /<filter([\\s>])/,\n          `<filter id=\"${ id }\"$1`\n        );\n      return create_svg_url(svg, id);\n    }),\n\n    var() {\n      return value => `var(${ value })`;\n    },\n\n    shape() {\n      return memo('shape-function', (type = '', ...args) => {\n        type = type.trim();\n        if (typeof shapes[type] === 'function') {\n          return shapes[type](args);\n        }\n        return '';\n      });\n    }\n\n  };\n\n  var Func = alias_for(Expose, {\n    'multi': 'multiple',\n    'm':     'multiple',\n    'ms':    'multiple-with-space',\n    'pn':    'pick-n',\n    'pd':    'pick-d',\n    'r':     'rand',\n    'ri':    'rand-int',\n    'p':     'pick',\n    'lp':    'last-pick',\n    'lr':    'last-rand',\n    'i':     'index',\n\n    // legacy names\n    'pick-by-turn': 'pick-n',\n    'max-row': 'size-row',\n    'max-col': 'size-col'\n  });\n\n  const is_seperator = c => /[,，\\s]/.test(c);\n\n  function skip_seperator(it) {\n    while (!it.end()) {\n      if (!is_seperator(it.curr(1))) break;\n      else it.next();\n    }\n  }\n\n  function parse$2(input) {\n    const it = iterator(input);\n    const result = [], stack = [];\n    let group = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c == '(') {\n        group += c;\n        stack.push(c);\n      }\n\n      else if (c == ')') {\n        group += c;\n        if (stack.length) {\n          stack.pop();\n        }\n      }\n\n      else if (stack.length) {\n        group += c;\n      }\n\n      else if (is_seperator(c)) {\n        result.push(group);\n        group = '';\n        skip_seperator(it);\n      }\n\n      else {\n        group += c;\n      }\n\n      it.next();\n    }\n\n    if (group) {\n      result.push(group);\n    }\n\n    return result;\n  }\n\n  let all = [];\n\n  function get_props(arg) {\n    if (!all.length) {\n      let props = new Set();\n      for (let n in document.head.style) {\n        if (!n.startsWith('-')) {\n          props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n      }\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n      all = Array.from(props);\n    }\n    return (arg && arg.test)\n      ? all.filter(n => arg.test(n))\n      : all;\n  }\n\n  function build_mapping(prefix) {\n    let reg = new RegExp(`\\\\-?${ prefix }\\\\-?`);\n    return get_props(reg)\n      .map(n => n.replace(reg, ''))\n      .reduce((obj, n) => { return obj[n] = n, obj }, {});\n  }\n\n  const props_webkit_mapping = build_mapping('webkit');\n  const props_moz_mapping = build_mapping('moz');\n\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return `-webkit-${ rule } ${ rule }`;\n    }\n    else if (props_moz_mapping[prop]) {\n      return `-moz-${ rule } ${ rule }`;\n    }\n    return rule;\n  }\n\n  var Property = {\n\n    ['@size'](value, { is_special_selector }) {\n      let [w, h = w] = parse$2(value);\n      return `\n      width: ${ w };\n      height: ${ h };\n      ${ is_special_selector ? '' : `\n        --internal-cell-width: ${ w };\n        --internal-cell-height: ${ h };\n      `}\n    `;\n    },\n\n    ['@min-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `min-width: ${ w }; min-height: ${ h };`;\n    },\n\n    ['@max-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `max-width: ${ w }; max-height: ${ h };`;\n    },\n\n    ['@place-cell']: (() => {\n      let map_left_right = {\n        'center': '50%', '0': '0%',\n        'left': '0%', 'right': '100%',\n        'top': '50%', 'bottom': '50%'\n      };\n      let map_top_bottom = {\n        'center': '50%', '0': '0%',\n        'top': '0%', 'bottom': '100%',\n        'left': '50%', 'right': '50%',\n      };\n\n      return value => {\n        let [left, top = '50%'] = parse$2(value);\n        left = map_left_right[left] || left;\n        top = map_top_bottom[top] || top;\n        const cw = 'var(--internal-cell-width, 25%)';\n        const ch = 'var(--internal-cell-height, 25%)';\n        return `\n        position: absolute;\n        left: ${ left };\n        top: ${ top };\n        width: ${ cw };\n        height: ${ ch };\n        margin-left: calc(${ cw } / -2) !important;\n        margin-top: calc(${ ch } / -2) !important;\n        grid-area: unset !important;\n      `;\n      }\n    })(),\n\n    ['@grid'](value, options) {\n      let [grid, size] = value.split('/').map(s => s.trim());\n      return {\n        grid: parse_grid(grid),\n        size: size ? this['@size'](size, options) : ''\n      };\n    },\n\n    ['@shape']: memo$1('shape-property', value => {\n      let [type, ...args] = parse$2(value);\n      let prop = 'clip-path';\n      if (!shapes[type]) return '';\n      let rules = `${ prop }: ${ shapes[type].apply(null, args) };`;\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n\n    ['@use'](rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    }\n\n  };\n\n  function build_expr(expr) {\n    return n => String(expr)\n      .replace(/(\\d+)(n)/g, '$1*' + n)\n      .replace(/n/g, n);\n  }\n\n  function nth(input, curr, max) {\n    let expr = build_expr(input);\n    for (let i = 0; i <= max; ++i) {\n      if (calc(expr(i)) == curr) return true;\n    }\n  }\n\n  const is$1 = {\n    even: n => !!(n % 2),\n    odd:  n => !(n % 2)\n  };\n\n  function even_or_odd(expr) {\n    return /^(even|odd)$/.test(expr);\n  }\n\n  var Selector = {\n\n    at({ x, y }) {\n      return (x1, y1) => (x == x1 && y == y1);\n    },\n\n    nth({ count, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](count - 1)\n          : nth(expr, count, grid.count)\n      );\n    },\n\n    row({ x, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](x - 1)\n          : nth(expr, x, grid.x)\n      );\n    },\n\n    col({ y, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](y - 1)\n          : nth(expr, y, grid.y)\n      );\n    },\n\n    even({ count }) {\n      return _ => is$1.even(count - 1);\n    },\n\n    odd({ count }) {\n      return _ => is$1.odd(count - 1);\n    },\n\n    random() {\n      return (ratio = .5) => {\n        if (ratio >= 1 && ratio <= 0) ratio = .5;\n        return Math.random() < ratio;\n      }\n    }\n\n  };\n\n  // Expose all Math functions and constants.\n  const methods = Object.getOwnPropertyNames(Math);\n\n  var MathFunc = methods.reduce((expose, n) => {\n    expose[n] = () => (...args) => {\n      if (typeof Math[n] === 'number') return Math[n];\n      return Math[n].apply(null, args.map(calc));\n    };\n    return expose;\n  }, {});\n\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n\n  class Rules {\n\n    constructor(tokens) {\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.coords = [];\n      this.reset();\n    }\n\n    reset() {\n      this.styles = {\n        host: '',\n        container: '',\n        cells: '',\n        keyframes: ''\n      };\n      this.coords = [];\n      for (let key in this.rules) {\n        if (key.startsWith('[cell]')) {\n          delete this.rules[key];\n        }\n      }\n    }\n\n    add_rule(selector, rule) {\n      let rules = this.rules[selector];\n      if (!rules) {\n        rules = this.rules[selector] = [];\n      }\n\n      rules.push.apply(rules, make_array(rule));\n    }\n\n    pick_func(name) {\n      return Func[name] || MathFunc[name];\n    }\n\n    compose_aname(...args) {\n      return args.join('-');\n    }\n\n    compose_selector(count, pseudo = '') {\n      return `[cell]:nth-of-type(${ count })${ pseudo }`;\n    }\n\n    compose_argument(argument, coords, idx) {\n      let result = argument.map(arg => {\n        if (arg.type == 'text') {\n          return arg.value;\n        }\n        else if (arg.type == 'func') {\n          let fn = this.pick_func(arg.name.substr(1));\n          if (fn) {\n            coords.idx = idx;\n            coords.position = arg.position;\n            let args = arg.arguments.map(n => {\n              return fn.lazy\n                ? idx => this.compose_argument(n, coords, idx)\n                : this.compose_argument(n, coords, idx);\n            });\n            return apply_args(fn, coords, args);\n          }\n        }\n      });\n\n      return (result.length >= 2)\n        ? result.join('')\n        : result[0];\n    }\n\n    compose_value(value, coords) {\n      if (!value || !value.reduce) return '';\n      return value.reduce((result, val) => {\n        switch (val.type) {\n          case 'text': {\n            result += val.value;\n            break;\n          }\n          case 'func': {\n            let fname = val.name.substr(1);\n            let fn = this.pick_func(fname);\n            if (fn) {\n              coords.position = val.position;\n              let args = val.arguments.map(arg => {\n                if (fn.lazy) {\n                  return idx => this.compose_argument(arg, coords, idx);\n                } else {\n                  return this.compose_argument(arg, coords);\n                }\n              });\n              result += apply_args(fn, coords, args);\n            }\n          }\n        }\n        return result;\n      }, '');\n    }\n\n    compose_rule(token, _coords, selector) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n      let value_group = token.value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords);\n        if (composed) ret.push(composed);\n        return ret;\n      }, []);\n\n      let value = value_group.join(', ');\n\n      if (/^animation(\\-name)?$/.test(prop)) {\n        this.props.has_animation = true;\n        if (coords.count > 1) {\n          let { count } = coords;\n          switch (prop) {\n            case 'animation-name': {\n              value = value_group\n                .map(n => this.compose_aname(n, count))\n                .join(', ');\n              break;\n            }\n            case 'animation': {\n              value = value_group\n                .map(n => {\n                  let group = (n || '').split(/\\s+/);\n                  group[0] = this.compose_aname(group[0], count);\n                  return group.join(' ');\n                })\n                .join(', ');\n            }\n          }\n        }\n      }\n\n      if (prop == 'content') {\n        if (!/[\"']|^none$|^(var|counter|counters|attr)\\(/.test(value)) {\n          value = `'${ value }'`;\n        }\n      }\n\n      if (prop == 'transition') {\n        this.props.has_transition = true;\n      }\n\n      let rule = `${ prop }: ${ value };`;\n      rule = prefixer(prop, rule);\n\n      if (prop == 'clip-path') {\n        // fix clip bug\n        rule += ';overflow: hidden;';\n      }\n\n      if (prop == 'width' || prop == 'height') {\n        if (!is_special_selector(selector)) {\n          rule += `--internal-cell-${ prop }: ${ value };`;\n        }\n      }\n\n      if (Property[prop]) {\n        let transformed = Property[prop](value, {\n          is_special_selector: is_special_selector(selector)\n        });\n        switch (prop) {\n          case '@grid': {\n            if (is_host_selector(selector)) {\n              this.grid = transformed.grid;\n              rule = transformed.size || '';\n            }\n            break;\n          }\n          case '@place-cell': {\n            if (!is_host_selector(selector)) {\n              rule = transformed;\n            }\n          }\n          case '@use': {\n            if (token.value.length) {\n              this.compose(coords, token.value);\n            }\n            rule = Property[prop](token.value);\n          }\n          default: {\n            rule = transformed;\n          }\n        }\n      }\n\n      return rule;\n    }\n\n    compose(coords, tokens) {\n      this.coords.push(coords);\n      (tokens || this.tokens).forEach((token, i) => {\n        if (token.skip) return false;\n        switch (token.type) {\n          case 'rule':\n            this.add_rule(\n              this.compose_selector(coords.count),\n              this.compose_rule(token, coords)\n            );\n            break;\n\n          case 'pseudo': {\n            if (token.selector.startsWith(':doodle')) {\n              token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n            }\n            let special = is_special_selector(token.selector);\n            if (special) {\n              token.skip = true;\n            }\n            token.selector.split(',').forEach(selector => {\n              let pseudo = token.styles.map(s =>\n                this.compose_rule(s, coords, selector)\n              );\n              let composed = special\n                ? selector\n                : this.compose_selector(coords.count, selector);\n              this.add_rule(composed, pseudo);\n            });\n\n            break;\n          }\n\n          case 'cond': {\n            let fn = Selector[token.name.substr(1)];\n            if (fn) {\n              let args = token.arguments.map(arg => {\n                return this.compose_argument(arg, coords);\n              });\n              let result = apply_args(fn, coords, args);\n              if (result) {\n                this.compose(coords, token.styles);\n              }\n            }\n            break;\n          }\n\n          case 'keyframes': {\n            if (!this.keyframes[token.name]) {\n              this.keyframes[token.name] = coords => `\n              ${ join(token.steps.map(step => `\n                ${ step.name } {\n                  ${ join(\n                    step.styles.map(s => this.compose_rule(s, coords))\n                  )}\n                }\n              `)) }\n            `;\n            }\n          }\n        }\n      });\n    }\n\n    output() {\n      Object.keys(this.rules).forEach((selector, i) => {\n        if (is_parent_selector(selector)) {\n          this.styles.container += `\n          .container {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        } else {\n          let target = is_host_selector(selector) ? 'host' : 'cells';\n          this.styles[target] += `\n          ${ selector } {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        }\n      });\n\n      let keyframes = Object.keys(this.keyframes);\n      this.coords.forEach((coords, i) => {\n        keyframes.forEach(name => {\n          let aname = this.compose_aname(name, coords.count);\n          this.styles.keyframes += `\n          ${ maybe(i == 0,\n            `@keyframes ${ name } {\n              ${ this.keyframes[name](coords) }\n            }`\n          )}\n          @keyframes ${ aname } {\n            ${ this.keyframes[name](coords) }\n          }\n        `;\n        });\n      });\n\n      return {\n        props: this.props,\n        styles: this.styles,\n        grid: this.grid\n      }\n    }\n  }\n\n  function generator(tokens, grid_size) {\n    let rules = new Rules(tokens);\n    let context = {};\n    rules.compose({\n      x : 1, y: 1, count: 1, context: {},\n      grid: { x : 1, y: 1, count: 1 }\n    });\n    let { grid } = rules.output();\n    if (grid) grid_size = grid;\n    rules.reset();\n\n    for (let x = 1, count = 0; x <= grid_size.x; ++x) {\n      for (let y = 1; y <= grid_size.y; ++y) {\n        rules.compose({ x, y, count: ++count, grid: grid_size, context });\n      }\n    }\n    return rules.output();\n  }\n\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({ mode: 'open' });\n      this.extra = {\n        get_custom_property_value: this.get_custom_property_value.bind(this)\n      };\n    }\n    connectedCallback() {\n      setTimeout(() => {\n        let compiled;\n        let use = this.getAttribute('use') || '';\n        if (use) use = `@use:${ use };`;\n        if (!this.innerHTML.trim() && !use) return false;\n        try {\n          let parsed = parse$1(use + this.innerHTML, this.extra);\n          this.grid_size = parse_grid(this.getAttribute('grid'));\n          compiled = generator(parsed, this.grid_size);\n          compiled.grid && (this.grid_size = compiled.grid);\n          this.build_grid(compiled);\n        } catch (e) {\n          this.innerHTML = '';\n          console.error(e && e.message || 'Error in css-doodle.');\n        }\n      });\n    }\n\n    get_custom_property_value(name) {\n      return getComputedStyle(this).getPropertyValue(name)\n        .trim()\n        .replace(/^\\(|\\)$/g, '');\n    }\n\n    build_grid(compiled) {\n      const { has_transition, has_animation } = compiled.props;\n      const { keyframes, host, container, cells } = compiled.styles;\n\n      this.doodle.innerHTML = `\n      <style>\n        ${ this.style_basic() }\n      </style>\n      <style class=\"style-keyframes\">\n        ${ keyframes }\n      </style>\n      <style class=\"style-container\">\n        ${ this.style_size() }\n        ${ host }\n        ${ container }\n      </style>\n      <style class=\"style-cells\">\n        ${ (has_transition || has_animation) ? '' : cells }\n      </style>\n      <div class=\"container\">\n        ${ this.html_cells() }\n      </div>\n    `;\n\n      if (has_transition || has_animation) {\n        setTimeout(() => {\n          this.set_style('.style-cells', cells);\n        }, 50);\n      }\n    }\n\n    inherit_props(p) {\n      return get_props(/grid/)\n        .map(n => `${ n }: inherit;`).join('');\n    }\n\n    style_basic() {\n      return `\n      :host {\n        display: block;\n        visibility: visible;\n        width: 1em;\n        height: 1em;\n      }\n      .container, [cell]:not(:empty) {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        display: grid;\n        ${ this.inherit_props() }\n      }\n      [cell]:empty {\n        position: relative;\n        line-height: 1;\n        box-sizing: border-box;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n    `;\n    }\n\n    style_size() {\n      let { x, y } = this.grid_size;\n      return `\n      :host {\n        grid-template-rows: repeat(${ x }, 1fr);\n        grid-template-columns: repeat(${ y }, 1fr);\n      }\n    `;\n    }\n\n    html_cells() {\n      let block = '<div cell></div>';\n      let cells = block.repeat(this.grid_size.count);\n      let depth = this.grid_size.z;\n\n      while (depth--) {\n        block = block.replace(/<div\\scell><\\/div>/g,\n          '<div cell>' + cells + '</div>'\n        );\n      }\n      return block.replace(/^<div\\scell>|<\\/div>$/g, '')\n    }\n\n    set_style(selector, styles) {\n      const el = this.shadowRoot.querySelector(selector);\n      el && (el.styleSheet\n        ? (el.styleSheet.cssText = styles )\n        : (el.innerHTML = styles));\n    }\n\n    update(styles) {\n      let use = this.getAttribute('use') || '';\n      if (use) use = `@use:${ use };`;\n\n      if (!styles) styles = this.innerHTML;\n      this.innerHTML = styles;\n\n      if (!this.grid_size) {\n        this.grid_size = parse_grid(this.getAttribute('grid'));\n      }\n\n      const compiled = generator(parse$1(use + styles, this.extra), this.grid_size);\n\n      if (compiled.grid) {\n        let { x, y, z } = compiled.grid;\n        let { x: gx, y: gy, z: gz } = this.grid_size;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, compiled.grid);\n          return this.build_grid(compiled);\n        }\n        Object.assign(this.grid_size, compiled.grid);\n      }\n\n      else {\n        let grid = parse_grid(this.getAttribute('grid'));\n        let { x, y, z } = grid;\n        let { x: gx, y: gy, z: gz } = this.grid_size;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, grid);\n          return this.build_grid(\n            generator(parse$1(use + styles, this.extra), this.grid_size)\n          );\n        }\n      }\n\n      this.set_style('.style-keyframes',\n        compiled.styles.keyframes\n      );\n      this.set_style('.style-container',\n          this.style_size()\n        + compiled.styles.host\n        + compiled.styles.container\n      );\n      this.set_style('.style-cells',\n        compiled.styles.cells\n      );\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.setAttribute('grid', grid);\n      this.connectedCallback();\n    }\n\n    get use() {\n      return this.getAttribute('use');\n    }\n\n    set use(use) {\n      this.setAttribute('use', use);\n      this.connectedCallback();\n    }\n\n    static get observedAttributes() {\n      return ['grid', 'use'];\n    }\n\n    attributeChangedCallback(name, old_val, new_val) {\n      if (old_val == new_val) {\n        return false;\n      }\n      if (name == 'grid' && old_val) {\n        this.grid = new_val;\n      }\n      if (name == 'use' && old_val) {\n        this.use = new_val;\n      }\n    }\n  }\n\n  customElements.define('css-doodle', Doodle);\n\n}));\n"],"sourceRoot":""}