{"version":3,"sources":["webpack:///./node_modules/css-doodle/css-doodle.js"],"names":["__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","iterator","input","index","col","line","curr","n","end","length","info","[object Object]","next","parse_var","trim","result","test","it","word","marks","groups","c","push","name","alternative","Error","pop","parse","e","console","error","message","make_array","arr","Array","isArray","join","spliter","last","first","flat_map","fn","prototype","flatMap","reduce","acc","x","concat","Tokens","func","type","arguments","argument","value","text","pseudo","selector","styles","cond","rule","property","keyframes","steps","step","is","white_space","line_break","number","isNaN","pair","includes","pair_of","\"","'","(","throw_error","msg","read_until","reset","read_word","read_keyframe_name","read_line","read_step","extra","read_rule","read_selector","read_steps","read_keyframes","read_comments","flag","inline","read_property","prop","read_arguments","args","group","stack","arg","trimLeft","read_func","normalize_argument","map","String","replace","ft","ed","cf","ce","slice","split","unshift","position","read_value","idx","skip","read_cond_selector","read_pseudo","read_var","read_cond","Object","assign","read_property_value","get_custom_property_value","ret","evaluate_value","values","forEach","v","vars","p","parsed","other","every","parse$1","apply","token","apply_args","f","clamp","num","min","max","Math","range","start","stop","count","old","initial","is_letter","lazy","wrap","sequence","i","total","parse_grid","size","y","z","Number","max_val","create_svg_url","svg","id","blob","Blob","url","URL","createObjectURL","encoded","encodeURIComponent","normalize_svg","xmlns","rand","t","lerp","random","by_unit","unit","some","str","matched","match","get_unit","restore","by_charcode","codes","charCodeAt","fromCharCode","calc","expr","tokens","operator","get_tokens","op_stack","op","infix_to_postfix","top","shift","right","left","compute","*","/","%","+","-",")","a","b","store","memo$1","prefix","key","expand","startsWith","build_range","Type","endsWith","from","get_tokens$1","to","reverse","cos","sin","sqrt","pow","PI","DEG","polygon","option","scale","deg","points","rotate","rad","shapes","circle","triangle","rhombus","pentagon","hexgon","hexagon","heptagon","octagon","star","diamond","cross","clover","k","m","astroid","hypocycloid","infinity","heart","bean","bicorn","pear","fish","whale","r","bud","d","obj","names","Func","_","row","grid","size-row","size-col","pick","context","last_pick","items","counter","pos","shuffle","last-pick","multiple","action","multitple-with-space","repeat","transform_type","last_rand","rand-int","parseInt","last-rand","hex","toString","svg-filter","substr","unique_id","var","shape","memo","multi","ms","pn","pd","ri","lp","lr","pick-by-turn","max-row","max-col","keys","is_seperator","skip_seperator","parse$2","all","get_props","props","Set","document","head","style","add","toLowerCase","has","filter","build_mapping","reg","RegExp","props_webkit_mapping","props_moz_mapping","prefixer","Property","is_special_selector","w","h","@place-cell","map_left_right","center","0","bottom","map_top_bottom","cw","ch","options","s","this","@shape","rules","nth","build_expr","is$1","even","odd","even_or_odd","Selector","at","x1","y1","exprs","ratio","MathFunc","getOwnPropertyNames","expose","is_host_selector","is_parent_selector","Rules","coords","host","container","cells","pick_func","compose_argument","val","fname","_coords","value_group","composed","compose_value","has_animation","compose_aname","has_transition","transformed","compose","add_rule","compose_selector","compose_rule","special","target","aname","maybe","generator","grid_size","output","customElements","define","HTMLElement","super","doodle","attachShadow","mode","bind","setTimeout","compiled","use","getAttribute","innerHTML","build_grid","getComputedStyle","getPropertyValue","style_basic","style_size","html_cells","set_style","inherit_props","block","depth","el","shadowRoot","querySelector","styleSheet","cssText","gx","gy","gz","setAttribute","connectedCallback","observedAttributes","old_val","new_val","call","exports","__webpack_require__","module"],"mappings":"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","file":"9-57d251d0821380189d41.js","sourcesContent":["(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) :\n  factory();\n}(function () { 'use strict';\n\n  function iterator(input) {\n    let index = 0, col = 1, line = 1;\n    return {\n      curr(n = 0) {\n        return input[index + n];\n      },\n      end() {\n        return input.length <= index;\n      },\n      info() {\n        return { index, col, line };\n      },\n      index(n) {\n        return (n === undefined ? index : index = n);\n      },\n      next() {\n        let next = input[index++];\n        if (next == '\\n') line++, col = 0;\n        else col++;\n        return next;\n      }\n    };\n  }\n\n  // I'll make it work first\n  function parse(it) {\n    let word = '', marks = [];\n    let groups = [], result = {};\n\n    while(!it.end()) {\n      let c = it.curr();\n      if (c == '(') {\n        marks.push(c);\n        word = '';\n      }\n      else if (c == ')' || c == ',') {\n        if (/^\\-\\-.+/.test(word)) {\n          if (!result.name) {\n            result.name = word;\n          } else {\n            if (!result.alternative) {\n              result.alternative = [];\n            }\n            result.alternative.push({\n              name: word\n            });\n          }\n        }\n\n        if (c == ')') {\n          if (marks[marks.length - 1] == '(') {\n            marks.pop();\n          } else {\n            throw new Error('bad match');\n          }\n        }\n\n        if (c == ',') {\n          if (!marks.length) {\n            groups.push(result);\n            result = {};\n          }\n        }\n\n        word = '';\n      }\n      else if (!/\\s/.test(c)) {\n        word += c;\n      }\n      it.next();\n    }\n\n    if (marks.length) {\n      return [];\n    }\n\n    if (result.name) {\n      groups.push(result);\n    }\n    return groups;\n  }\n\n  function parse_var(input) {\n    input = input.trim();\n    let result = [];\n    if (!/^var\\(/.test(input)) {\n      return result;\n    }\n    let it = iterator(input);\n    try {\n      result = parse(it);\n    } catch (e) {\n      console.error(e && e.message || 'Bad variables.');\n    }\n    return result;\n  }\n\n  function make_array(arr) {\n    return Array.isArray(arr) ? arr : [arr];\n  }\n\n  function join(arr, spliter = '\\n') {\n    return (arr || []).join(spliter);\n  }\n\n  function last(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function first(arr) {\n    return arr[0];\n  }\n\n  function shuffle(arr) {\n    let ret = Array.from ? Array.from(arr) : arr.slice();\n    let m = arr.length;\n    while (m) {\n      let i = ~~(Math.random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n\n  function flat_map(arr, fn) {\n    if (Array.prototype.flatMap) return arr.flatMap(fn);\n    return arr.reduce((acc, x) => acc.concat(fn(x)), []);\n  }\n\n  const Tokens = {\n    func(name = '') {\n      return {\n        type: 'func',\n        name,\n        arguments: []\n      };\n    },\n    argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n    text(value = '') {\n      return {\n        type: 'text',\n        value\n      };\n    },\n    pseudo(selector = '') {\n      return {\n        type: 'pseudo',\n        selector,\n        styles: []\n      };\n    },\n    cond(name = '') {\n      return {\n        type: 'cond',\n        name,\n        styles: [],\n        arguments: []\n      };\n    },\n    rule(property = '') {\n      return {\n        type: 'rule',\n        property,\n        value: []\n      };\n    },\n    keyframes(name = '') {\n      return {\n        type: 'keyframes',\n        name,\n        steps: []\n      }\n    },\n\n    step(name = '') {\n      return {\n        type: 'step',\n        name,\n        styles: []\n      }\n    }\n  };\n\n  const is = {\n    white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n    line_break(c) {\n      return /\\n/.test(c);\n    },\n    number(n) {\n      return !isNaN(n);\n    },\n    pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n    pair_of(c, n) {\n      return ({ '\"': '\"', \"'\": \"'\", '(': ')' })[c] == n;\n    }\n  };\n\n  function throw_error(msg, { col, line }) {\n    console.error(\n      `(at line ${ line }, column ${ col }) ${ msg }`\n    );\n  }\n\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim()\n    } else {\n      return input;\n    }\n  }\n\n  function read_until(fn) {\n    return function(it, reset) {\n      let index = it.index();\n      let word = '';\n      while (!it.end()) {\n        let c = it.next();\n        if (fn(c)) break;\n        else word += c;\n      }\n      if (reset) {\n        it.index(index);\n      }\n      return word;\n    }\n  }\n\n  function read_word(it, reset) {\n    let check = c => /[^\\w@]/.test(c);\n    return read_until(check)(it, reset);\n  }\n\n  function read_keyframe_name(it) {\n    return read_until(c => /[\\s\\{]/.test(c))(it);\n  }\n\n  function read_line(it, reset) {\n    let check = c => is.line_break(c) || c == '{';\n    return read_until(check)(it, reset);\n  }\n\n  function read_step(it, extra) {\n    let c, step = Tokens.step();\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!step.name.length) {\n        step.name = read_selector(it);\n      }\n      else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return step;\n  }\n\n  function read_steps(it, extra) {\n    const steps = [];\n    let c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n    return steps;\n  }\n\n  function read_keyframes(it, extra) {\n    let keyframes = Tokens.keyframes(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n        continue;\n      }\n      else if (c == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n    return keyframes;\n  }\n\n  function read_comments(it, flag = {}) {\n    it.next();\n    while (!it.end()) {\n      let c = it.curr();\n      if (flag.inline) {\n        if (c == '\\n') break;\n      }\n      else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n      it.next();\n    }\n    if (!flag.inline) {\n      it.next(); it.next();\n    }\n  }\n\n  function read_property(it) {\n    let prop = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;\n      else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n    return prop;\n  }\n\n  function read_arguments(it) {\n    let args = [], group = [], stack = [], arg = '', c;\n    while (!it.end()) {\n      c = it.curr();\n\n      if ((/[\\('\"`]/.test(c) && it.curr(-1) !== '\\\\')) {\n        if (stack.length) {\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n        arg += c;\n      }\n      else if (c == '@') {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n        group.push(read_func(it));\n      }\n      else if (/[,)]/.test(c)) {\n        if (stack.length) {\n          if (c == ')') {\n            stack.pop();\n          }\n          arg += c;\n        }\n\n        else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else {\n              if (arg.length) {\n                group.push(Tokens.text(arg));\n              }\n            }\n          }\n\n          args.push(normalize_argument(group));\n          [group, arg] = [[], ''];\n\n          if (c == ')') break;\n        }\n      }\n      else {\n        arg += c;\n      }\n      it.next();\n    }\n    return args;\n  }\n\n  function normalize_argument(group) {\n    let result = group.map(arg => {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        let value = String(arg.value);\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n        arg.value = value.replace(/\\n+|\\s+/g, ' ');\n      }\n      return arg;\n    });\n\n    let ft = first(result) || {};\n    let ed = last(result) || {};\n    if (ft.type == 'text' && ed.type == 'text') {\n      let cf = first(ft.value);\n      let ce  = last(ed.value);\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair(cf) && is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n        }\n      }\n    }\n    return result;\n  }\n\n  function read_func(it) {\n    let func = Tokens.func();\n    let extra = '', name = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ')') break;\n      if (c == '(') {\n        it.next();\n        func.name = name;\n        func.arguments = read_arguments(it);\n        if (/\\d$/.test(name)) {\n          func.name = name.split(/\\d+/)[0];\n          extra = name.split(/\\D+/)[1];\n        }\n        if (extra.length) {\n          func.arguments.unshift([{\n            type: 'text',\n            value: extra\n          }]);\n        }\n        func.position = it.info().index;\n        break;\n      }\n      else name += c;\n      it.next();\n    }\n    return func;\n  }\n\n  function read_value(it) {\n    let text = Tokens.text(), idx = 0, skip = true, c;\n    const value = [], stack = [];\n    value[idx] = [];\n\n    while (!it.end()) {\n      c = it.curr();\n\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      }\n      else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[++idx] = [];\n        skip = true;\n      }\n      else if (/[;}]/.test(c)) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        break;\n      }\n      else if (c == '@') {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[idx].push(read_func(it));\n      }\n      else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n        text.value += c;\n      }\n      it.next();\n    }\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n    return value;\n  }\n\n  function read_selector(it) {\n    let selector = '', c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;\n      else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_cond_selector(it) {\n    let selector = { name: '', arguments: [] }, c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it);\n      }\n      else if (/[){]/.test(c)) break;\n      else if (!is.white_space(c)) selector.name += c;\n      it.next();\n    }\n    return selector;\n  }\n\n  function read_pseudo(it, extra) {\n    let pseudo = Tokens.pseudo(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      }\n      else {\n        let rule = read_rule(it, extra);\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(\n            rule.value\n          );\n        } else {\n          pseudo.styles.push(rule);\n        }\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return pseudo;\n  }\n\n  function read_rule(it, extra) {\n    let rule = Tokens.rule(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ';') break;\n      else if (!rule.property.length) {\n        rule.property = read_property(it);\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      }\n      else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n    return rule;\n  }\n\n  function read_cond(it, extra) {\n    let cond = Tokens.cond(), c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return cond;\n  }\n\n  function read_property_value(extra, name) {\n    let rule = '';\n    if (extra && extra.get_custom_property_value) {\n      rule = extra.get_custom_property_value(name);\n    }\n    return rule;\n  }\n\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(v => {\n      if (v.type == 'text' && v.value) {\n        let vars = parse_var(v.value);\n        v.value = vars.reduce((ret, p) => {\n          let rule = '', other = '', parsed;\n          rule = read_property_value(extra, p.name);\n          if (!rule && p.alternative) {\n            p.alternative.every(n => {\n              other = read_property_value(extra, n.name);\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n          try {\n            parsed = parse$1(rule, extra);\n          } catch (e) { }\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n          return ret;\n        }, []);\n      }\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(arg => {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n\n  function read_var(it, extra) {\n    it.next();\n    let groups = read_value(it) || [];\n    return groups.reduce((ret, group) => {\n      evaluate_value(group, extra);\n      let [token] = group;\n      if (token.value && token.value.length) {\n        ret.push(...token.value);\n      }\n      return ret;\n    }, []);\n  }\n\n  function parse$1(input, extra) {\n    const it = iterator(input);\n    const Tokens = [];\n    while (!it.end()) {\n      let c = it.curr();\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      }\n      else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      }\n      else if (c == '/' && it.curr(1) == '/') {\n        read_comments(it, { inline: true });\n      }\n      else if (c == ':') {\n        let pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      }\n      else if (c == '@' && read_word(it, true) === '@keyframes') {\n        let keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      }\n      else if (c == '@' && !read_line(it, true).includes(':')) {\n        let cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      }\n      else if (!is.white_space(c)) {\n        let rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n      it.next();\n    }\n    return Tokens;\n  }\n\n  function apply_args(fn, ...args) {\n    return args.reduce((f, arg) =>\n      f.apply(null, make_array(arg)), fn\n    );\n  }\n\n  function clamp(num, min, max) {\n    return Math.max(min, Math.min(max, num));\n  }\n\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return (typeof value === 'function') ? value() : value;\n  }\n\n  function range(start, stop, step) {\n    let count = 0, old = start;\n    let initial = n => (n > 0 && n < 1) ? .1 : 1;\n    let length = arguments.length;\n    if (length == 1) [start, stop] = [initial(start), start];\n    if (length < 3) step = initial(start);\n    let range = [];\n    while ((step >= 0 && start <= stop)\n      || (step < 0 && start > stop)) {\n      range.push(start);\n      start += step;\n      if (count++ >= 1000) break;\n    }\n    if (!range.length) range.push(old);\n    return range;\n  }\n\n  function alias_for(obj, names) {\n    Object.keys(names).forEach(n => {\n      obj[n] = obj[names[n]];\n    });\n    return obj;\n  }\n\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n\n  function lazy(fn) {\n    let wrap = () => fn;\n    wrap.lazy = true;\n    return wrap;\n  }\n\n  function sequence(count, fn) {\n    let ret = [];\n    for (let i = 0; i < count; ++i) {\n      ret.push(fn(i));\n    }\n    return ret;\n  }\n\n  const [ min, max, total ] = [ 1, 32, 32 * 32 ];\n\n  function parse_grid(size) {\n    let [x, y, z] = (size + '')\n      .replace(/\\s+/g, '')\n      .replace(/[,xX]+/g, 'x')\n      .split('x')\n      .map(Number);\n\n    const max_val = (x == 1 || y == 1) ? total : max;\n\n    const ret = {\n      x: clamp(x || min, 1, max_val),\n      y: clamp(y || x || min, 1, max_val),\n      z: clamp(z || min, 1, max_val)\n    };\n\n    return Object.assign({}, ret,\n      { count: ret.x * ret.y }\n    );\n  }\n\n  function create_svg_url(svg, id) {\n    if (id) {\n      let blob = new Blob([svg], { type: 'image/svg+xml' });\n      let url = URL.createObjectURL(blob);\n      return `url(${ url }#${ id })`;\n    }\n    else {\n      let encoded = encodeURIComponent(svg);\n      return `url(\"data:image/svg+xml;utf8,${ encoded }\")`;\n    }\n  }\n\n  function normalize_svg(input) {\n    const xmlns = 'xmlns=\"http://www.w3.org/2000/svg\"';\n    if (!input.includes('<svg')) {\n      input = `<svg ${ xmlns }>${ input }</svg>`;\n    }\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, `<svg ${ xmlns }$1`);\n    }\n    return input;\n  }\n\n  function lerp(start, end, t) {\n    return start * (1 - t) + end * t;\n  }\n\n  function rand(start = 0, end = start) {\n    if (arguments.length == 1) {\n      start = start < 1 ? .1 : 1;\n    }\n    return lerp(start, end, Math.random());\n  }\n\n  function pick(...items) {\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(Math.random() * args.length)];\n  }\n\n  function unique_id(prefix = '') {\n    return prefix + Math.random().toString(32).substr(2);\n  }\n\n  function by_unit(fn) {\n    return (...args) => {\n      let unit = get_unit(args);\n      return restore(fn, unit).apply(null, args);\n    }\n  }\n\n  function restore(fn, unit) {\n    return (...args) => {\n      args = args.map(str => Number(\n        String(str).replace(/\\D+$/g, '')\n      ));\n      let result = fn.apply(null, args);\n      if (!unit.length) {\n        return result;\n      }\n      if (Array.isArray(result)) {\n        return result.map(n => n + unit);\n      }\n      return result + unit;\n    }\n  }\n\n  function get_unit(values) {\n    let unit = '';\n    values.some(str => {\n      let input = String(str).trim();\n      if (!input) return '';\n      let matched = input.match(/\\d(\\D+)$/);\n      return (unit = matched ? matched[1] : '');\n    });\n    return unit;\n  }\n\n  function by_charcode(fn) {\n    return (...args) => {\n      let codes = args.map(n => String(n).charCodeAt(0));\n      let result = fn.apply(null, codes);\n      return Array.isArray(result)\n        ? result.map(n => String.fromCharCode(n))\n        : String.fromCharCode(result);\n    }\n  }\n\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n\n  function calc(input) {\n    const expr = infix_to_postfix(input), stack = [];\n    while (expr.length) {\n      let top = expr.shift();\n      if (/\\d+/.test(top)) stack.push(top);\n      else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(\n          top, Number(left), Number(right)\n        ));\n      }\n    }\n    return stack[0];\n  }\n\n  const operator = {\n    '*': 3, '/': 3, '%': 3,\n    '+': 2, '-': 2,\n    '(': 1, ')': 1\n  };\n\n  function get_tokens(input) {\n    let expr = String(input);\n    let tokens = [], num = '';\n\n    for (let i = 0; i < expr.length; ++i) {\n      let c = expr[i];\n\n      if (operator[c]) {\n        if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        }\n        else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          let { type, value } = last(tokens) || {};\n          if (type == 'operator'\n              && !num.length\n              && /[^()]/.test(c)\n              && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({ type: 'number', value: num });\n              num = '';\n            }\n            tokens.push({ type: 'operator', value: c });\n          }\n        }\n      }\n\n      else if (/\\S/.test(c)) {\n        num += c;\n      }\n    }\n\n    if (num.length) {\n      tokens.push({ type: 'number', value: num });\n    }\n\n    return tokens;\n  }\n\n  function infix_to_postfix(input) {\n    let tokens = get_tokens(input);\n    const op_stack = [], expr = [];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      let { type, value } = tokens[i];\n      if (type == 'number') {\n        expr.push(value);\n      }\n\n      else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        }\n\n        else if (value == ')') {\n          while (op_stack.length && last(op_stack) != '(') {\n            expr.push(op_stack.pop());\n          }\n          op_stack.pop();\n        }\n\n        else {\n          while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n            let op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push(op);\n          }\n          op_stack.push(value);\n        }\n      }\n    }\n\n    while (op_stack.length) {\n      expr.push(op_stack.pop());\n    }\n\n    return expr;\n  }\n\n  function compute(op, a, b) {\n    switch (op) {\n      case '+': return a + b;\n      case '-': return a - b;\n      case '*': return a * b;\n      case '/': return a / b;\n      case '%': return a % b;\n    }\n  }\n\n  const store = {};\n\n  function memo$1(prefix, fn) {\n    return (...args) => {\n      let key = prefix + args.join('-');\n      if (store[key]) return store[key];\n      return (store[key] = fn.apply(null, args));\n    }\n  }\n\n  function expand(fn) {\n    return (...args) => fn.apply(null, flat_map(args, n =>\n      String(n).startsWith('[') ? build_range(n) : n\n    ));\n  }\n\n  function Type(type, value) {\n    return { type, value };\n  }\n\n  function get_tokens$1(input) {\n    let expr = String(input);\n    let tokens = [], stack = [];\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n\n    for (let i = 1; i < expr.length - 1; ++i) {\n      let c = expr[i];\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n      if (last(stack) == '-') {\n        stack.pop();\n        let from = stack.pop();\n        tokens.push(from\n          ? Type('range', [ from, c ])\n          : Type('char', c)\n        );\n        continue;\n      }\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n      stack.push(c);\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    return tokens;\n  }\n\n  const build_range = memo$1('build_range', (input) => {\n    let tokens = get_tokens$1(input);\n    return flat_map(tokens, ({ type, value }) => {\n      if (type == 'char') return value;\n      let [ from, to ] = value;\n      let reverse = false;\n      if (from > to) {\n        [from, to] = [ to, from ];\n        reverse = true;\n      }\n      let result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n\n  const { cos, sin, sqrt, pow, PI } = Math;\n  const DEG = PI / 180;\n\n  function polygon(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n\n    if (!fn) {\n      fn = t => [ cos(t), sin(t) ];\n    }\n\n    let split = option.split || 120;\n    let scale = option.scale || 1;\n    let start = DEG * (option.start || 0);\n    let deg = option.deg ? (option.deg * DEG) : (PI / (split / 2));\n    let points = [];\n\n    for (let i = 0; i < split; ++i) {\n      let t = start + deg * i;\n      let [x, y] = fn(t);\n      points.push(\n        ((x * 50 * scale) + 50 + '% ') +\n        ((y * 50 * scale) + 50 + '%')\n      );\n    }\n\n    return option.type\n      ? `polygon(${ option.type }, ${ points.join(',') })`\n      : `polygon(${ points.join(',') })`;\n  }\n\n  function rotate(x, y, deg) {\n    let rad = DEG * deg;\n    return [\n      x * cos(rad) - y * sin(rad),\n      y * cos(rad) + x * sin(rad)\n    ];\n  }\n\n  const shapes =  {\n\n    circle() {\n      return 'circle(49%)';\n    },\n\n    triangle() {\n      return polygon({ split: 3, start: -90 }, t => [\n        cos(t) * 1.1,\n        sin(t) * 1.1 + .2\n      ]);\n    },\n\n    rhombus() {\n      return polygon({ split: 4 });\n    },\n\n    pentagon() {\n      return polygon({ split: 5, start: 54 });\n    },\n\n    hexgon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    hexagon() {\n      return polygon({ split: 6, start: 30 });\n    },\n\n    heptagon() {\n      return polygon({ split: 7, start: -90 });\n    },\n\n    octagon() {\n      return polygon({ split: 8, start: 22.5 });\n    },\n\n    star() {\n      return polygon({ split: 5, start: 54, deg: 144 });\n    },\n\n    diamond() {\n      return 'polygon(50% 5%, 80% 50%, 50% 95%, 20% 50%)';\n    },\n\n    cross() {\n      return `polygon(\n      5% 35%,  35% 35%, 35% 5%,  65% 5%,\n      65% 35%, 95% 35%, 95% 65%, 65% 65%,\n      65% 95%, 35% 95%, 35% 65%, 5% 65%\n    )`;\n    },\n\n    clover(k = 3) {\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return polygon({ split: 240 }, t => {\n        let x = cos(k * t) * cos(t);\n        let y = cos(k * t) * sin(t);\n        if (k == 3) x -= .2;\n        if (k == 2) {\n          x /= 1.1;\n          y /= 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    hypocycloid(k = 3) {\n      k = clamp(k, 3, 6);\n      let m = 1 - k;\n      return polygon({ scale: 1 / k  }, t => {\n        let x = m * cos(t) + cos(m * (t - PI));\n        let y = m * sin(t) + sin(m * (t - PI));\n        if (k == 3) {\n          x = x * 1.1 - .6;\n          y = y * 1.1;\n        }\n        return [x, y];\n      });\n    },\n\n    astroid() {\n      return shapes.hypocycloid(4);\n    },\n\n    infinity() {\n      return polygon(t => {\n        let a = .7 * sqrt(2) * cos(t);\n        let b = (pow(sin(t), 2) + 1);\n        return [\n          a / b,\n          a * sin(t) / b\n        ]\n      });\n    },\n\n    heart() {\n      return polygon(t => {\n        let x = .75 * pow(sin(t), 3);\n        let y =\n            cos(1 * t) * (13 / 18)\n          - cos(2 * t) * (5 / 18)\n          - cos(3 * t) / 18\n          - cos(4 * t) / 18;\n        return rotate(\n          x * 1.2,\n          (y + .2) * 1.1,\n          180\n        );\n      });\n    },\n\n    bean() {\n      return polygon(t => {\n        let [a, b] = [pow(sin(t), 3), pow(cos(t), 3)];\n        return rotate(\n          (a + b) * cos(t) * 1.3 - .45,\n          (a + b) * sin(t) * 1.3 - .45,\n          -90\n        );\n      });\n    },\n\n    bicorn() {\n      return polygon(t => rotate(\n        cos(t),\n        pow(sin(t), 2) / (2 + sin(t)) - .5,\n        180\n      ));\n    },\n\n    pear() {\n      return polygon(t => [\n        sin(t),\n        (1 + sin(t)) * cos(t) / 1.4\n      ]);\n    },\n\n    fish() {\n      return polygon(t => [\n        cos(t) - pow(sin(t), 2) / sqrt(2),\n        sin(2 * t) / 2\n      ]);\n    },\n\n    whale() {\n      return polygon({ split: 240 }, t => {\n        let r = 3.4 * (pow(sin(t), 2) - .5) * cos(t);\n        return rotate(\n          cos(t) * r + .75,\n          sin(t) * r * 1.2,\n          180\n        );\n      });\n    },\n\n    bud(n = 3) {\n      n = clamp(n, 3, 10);\n      return polygon({ split: 240 }, t => [\n        ((1 + .2 * cos(n * t)) * cos(t)) * .8,\n        ((1 + .2 * cos(n * t)) * sin(t)) * .8\n      ]);\n    },\n\n    alien(...args) {\n      let [a = 1, b = 1, c = 1, d = 1, e = 1]\n        = args.map(n => clamp(n, 1, 9));\n      return polygon({ split: 480, type: 'evenodd' }, t => [\n        (cos(t * a) + cos(t * c) + cos(t * e)) * .31,\n        (sin(t * b) + sin(t * d) + sin(t)) * .31\n      ]);\n    }\n\n  };\n\n  const Expose = {\n\n    index({ count }) {\n      return _ => count;\n    },\n\n    row({ x }) {\n      return _ => x;\n    },\n\n    col({ y }) {\n      return _ => y;\n    },\n\n    size({ grid }) {\n      return _ => grid.count;\n    },\n\n    ['size-row']({ grid }) {\n      return _ => grid.x;\n    },\n\n    ['size-col']({ grid }) {\n      return _ => grid.y;\n    },\n\n    n({ idx }) {\n      return _ => idx || 0;\n    },\n\n    pick({ context }) {\n      return expand((...args) => (\n        context.last_pick = pick(args)\n      ));\n    },\n\n    ['pick-n']({ idx, context, position }) {\n      let counter = 'pn-counter' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        let max = args.length;\n        let pos = ((idx == undefined ? context[counter] : idx) - 1) % max;\n        return context.last_pick = args[pos];\n      });\n    },\n\n    ['pick-d']({ idx, context, position }) {\n      let counter = 'pd-counter' + position;\n      let values = 'pd-values' + position;\n      return expand((...args) => {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        if (!context[values]) {\n          context[values] = shuffle(args);\n        }\n        let max = args.length;\n        let pos = ((idx == undefined ? context[counter] : idx) - 1) % max;\n        return context.last_pick = context[values][pos];\n      });\n    },\n\n    ['last-pick']({ context }) {\n      return () => context.last_pick;\n    },\n\n    multiple: lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(n(), 0, 65536);\n      return sequence(count, i => action(i + 1)).join(',');\n    }),\n\n    ['multitple-with-space']: lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(n(), 0, 65536);\n      return sequence(count, i => action(i + 1)).join(' ');\n    }),\n\n    repeat: lazy((n, action) => {\n      if (!action || !n) return '';\n      let count = clamp(n(), 0, 65536);\n      return sequence(count, i => action(i + 1)).join('');\n    }),\n\n    rand({ context }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter)\n          ? by_charcode\n          : by_unit;\n        let value = transform_type(rand).apply(null, args);\n        return context.last_rand = value;\n      };\n    },\n\n    ['rand-int']({ context }) {\n      return (...args) => {\n        let transform_type = args.every(is_letter)\n          ? by_charcode\n          : by_unit;\n        let value = parseInt(\n          transform_type(rand).apply(null, args)\n        );\n        return context.last_rand = value;\n      }\n    },\n\n    ['last-rand']({ context }) {\n      return () => context.last_rand;\n    },\n\n    calc() {\n      return value => calc(value);\n    },\n\n    hex() {\n      return value => parseInt(value).toString(16);\n    },\n\n    svg: lazy(input => {\n      if (input === undefined) return '';\n      let svg = normalize_svg(input().trim());\n      return create_svg_url(svg);\n    }),\n\n    ['svg-filter']: lazy(input => {\n      if (input === undefined) return '';\n      let id = unique_id('filter-');\n      let svg = normalize_svg(input().trim())\n        .replace(\n          /<filter([\\s>])/,\n          `<filter id=\"${ id }\"$1`\n        );\n      return create_svg_url(svg, id);\n    }),\n\n    var() {\n      return value => `var(${ value })`;\n    },\n\n    shape() {\n      return memo('shape-function', (type = '', ...args) => {\n        type = type.trim();\n        if (typeof shapes[type] === 'function') {\n          return shapes[type](args);\n        }\n        return '';\n      });\n    }\n\n  };\n\n  var Func = alias_for(Expose, {\n    'multi': 'multiple',\n    'm':     'multiple',\n    'ms':    'multiple-with-space',\n    'pn':    'pick-n',\n    'pd':    'pick-d',\n    'r':     'rand',\n    'ri':    'rand-int',\n    'p':     'pick',\n    'lp':    'last-pick',\n    'lr':    'last-rand',\n    'i':     'index',\n\n    // legacy names\n    'pick-by-turn': 'pick-n',\n    'max-row': 'size-row',\n    'max-col': 'size-col'\n  });\n\n  const is_seperator = c => /[,\\s]/.test(c);\n\n  function skip_seperator(it) {\n    while (!it.end()) {\n      if (!is_seperator(it.curr(1))) break;\n      else it.next();\n    }\n  }\n\n  function parse$2(input) {\n    const it = iterator(input);\n    const result = [], stack = [];\n    let group = '';\n\n    while (!it.end()) {\n      let c = it.curr();\n      if (c == '(') {\n        group += c;\n        stack.push(c);\n      }\n\n      else if (c == ')') {\n        group += c;\n        if (stack.length) {\n          stack.pop();\n        }\n      }\n\n      else if (stack.length) {\n        group += c;\n      }\n\n      else if (is_seperator(c)) {\n        result.push(group);\n        group = '';\n        skip_seperator(it);\n      }\n\n      else {\n        group += c;\n      }\n\n      it.next();\n    }\n\n    if (group) {\n      result.push(group);\n    }\n\n    return result;\n  }\n\n  let all = [];\n\n  function get_props(arg) {\n    if (!all.length) {\n      let props = new Set();\n      for (let n in document.head.style) {\n        if (!n.startsWith('-')) {\n          props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n      }\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n      all = Array.from(props);\n    }\n    return (arg && arg.test)\n      ? all.filter(n => arg.test(n))\n      : all;\n  }\n\n  function build_mapping(prefix) {\n    let reg = new RegExp(`\\\\-?${ prefix }\\\\-?`);\n    return get_props(reg)\n      .map(n => n.replace(reg, ''))\n      .reduce((obj, n) => { return obj[n] = n, obj }, {});\n  }\n\n  const props_webkit_mapping = build_mapping('webkit');\n  const props_moz_mapping = build_mapping('moz');\n\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return `-webkit-${ rule } ${ rule }`;\n    }\n    else if (props_moz_mapping[prop]) {\n      return `-moz-${ rule } ${ rule }`;\n    }\n    return rule;\n  }\n\n  var Property = {\n\n    ['@size'](value, { is_special_selector }) {\n      let [w, h = w] = parse$2(value);\n      return `\n      width: ${ w };\n      height: ${ h };\n      ${ is_special_selector ? '' : `\n        --internal-cell-width: ${ w };\n        --internal-cell-height: ${ h };\n      `}\n    `;\n    },\n\n    ['@min-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `min-width: ${ w }; min-height: ${ h };`;\n    },\n\n    ['@max-size'](value) {\n      let [w, h = w] = parse$2(value);\n      return `max-width: ${ w }; max-height: ${ h };`;\n    },\n\n    ['@place-cell']: (() => {\n      let map_left_right = {\n        'center': '50%', '0': '0%',\n        'left': '0%', 'right': '100%',\n        'top': '50%', 'bottom': '50%'\n      };\n      let map_top_bottom = {\n        'center': '50%', '0': '0%',\n        'top': '0%', 'bottom': '100%',\n        'left': '50%', 'right': '50%',\n      };\n\n      return value => {\n        let [left, top = '50%'] = parse$2(value);\n        left = map_left_right[left] || left;\n        top = map_top_bottom[top] || top;\n        const cw = 'var(--internal-cell-width, 25%)';\n        const ch = 'var(--internal-cell-height, 25%)';\n        return `\n        position: absolute;\n        left: ${ left };\n        top: ${ top };\n        width: ${ cw };\n        height: ${ ch };\n        margin-left: calc(${ cw } / -2) !important;\n        margin-top: calc(${ ch } / -2) !important;\n        grid-area: unset !important;\n      `;\n      }\n    })(),\n\n    ['@grid'](value, options) {\n      let [grid, size] = value.split('/').map(s => s.trim());\n      return {\n        grid: parse_grid(grid),\n        size: size ? this['@size'](size, options) : ''\n      };\n    },\n\n    ['@shape']: memo$1('shape-property', value => {\n      let [type, ...args] = parse$2(value);\n      let prop = 'clip-path';\n      if (!shapes[type]) return '';\n      let rules = `${ prop }: ${ shapes[type].apply(null, args) };`;\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n\n    ['@use'](rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    }\n\n  };\n\n  function build_expr(expr) {\n    return n => String(expr)\n      .replace(/(\\d+)(n)/g, '$1*' + n)\n      .replace(/n/g, n);\n  }\n\n  function nth(input, curr, max) {\n    let expr = build_expr(input);\n    for (let i = 0; i <= max; ++i) {\n      if (calc(expr(i)) == curr) return true;\n    }\n  }\n\n  const is$1 = {\n    even: n => !!(n % 2),\n    odd:  n => !(n % 2)\n  };\n\n  function even_or_odd(expr) {\n    return /^(even|odd)$/.test(expr);\n  }\n\n  var Selector = {\n\n    at({ x, y }) {\n      return (x1, y1) => (x == x1 && y == y1);\n    },\n\n    nth({ count, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](count - 1)\n          : nth(expr, count, grid.count)\n      );\n    },\n\n    row({ x, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](x - 1)\n          : nth(expr, x, grid.x)\n      );\n    },\n\n    col({ y, grid }) {\n      return (...exprs) => exprs.some(expr =>\n        even_or_odd(expr)\n          ? is$1[expr](y - 1)\n          : nth(expr, y, grid.y)\n      );\n    },\n\n    even({ count }) {\n      return _ => is$1.even(count - 1);\n    },\n\n    odd({ count }) {\n      return _ => is$1.odd(count - 1);\n    },\n\n    random() {\n      return (ratio = .5) => {\n        if (ratio >= 1 && ratio <= 0) ratio = .5;\n        return Math.random() < ratio;\n      }\n    }\n\n  };\n\n  // Expose all Math functions and constants.\n  const methods = Object.getOwnPropertyNames(Math);\n\n  var MathFunc = methods.reduce((expose, n) => {\n    expose[n] = () => (...args) => {\n      if (typeof Math[n] === 'number') return Math[n];\n      return Math[n].apply(null, args.map(calc));\n    };\n    return expose;\n  }, {});\n\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n\n  class Rules {\n\n    constructor(tokens) {\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.coords = [];\n      this.reset();\n    }\n\n    reset() {\n      this.styles = {\n        host: '',\n        container: '',\n        cells: '',\n        keyframes: ''\n      };\n      this.coords = [];\n      for (let key in this.rules) {\n        if (key.startsWith('[cell]')) {\n          delete this.rules[key];\n        }\n      }\n    }\n\n    add_rule(selector, rule) {\n      let rules = this.rules[selector];\n      if (!rules) {\n        rules = this.rules[selector] = [];\n      }\n\n      rules.push.apply(rules, make_array(rule));\n    }\n\n    pick_func(name) {\n      return Func[name] || MathFunc[name];\n    }\n\n    compose_aname(...args) {\n      return args.join('-');\n    }\n\n    compose_selector(count, pseudo = '') {\n      return `[cell]:nth-of-type(${ count })${ pseudo }`;\n    }\n\n    compose_argument(argument, coords, idx) {\n      let result = argument.map(arg => {\n        if (arg.type == 'text') {\n          return arg.value;\n        }\n        else if (arg.type == 'func') {\n          let fn = this.pick_func(arg.name.substr(1));\n          if (fn) {\n            coords.idx = idx;\n            coords.position = arg.position;\n            let args = arg.arguments.map(n => {\n              return fn.lazy\n                ? idx => this.compose_argument(n, coords, idx)\n                : this.compose_argument(n, coords, idx);\n            });\n            return apply_args(fn, coords, args);\n          }\n        }\n      });\n\n      return (result.length >= 2)\n        ? result.join('')\n        : result[0];\n    }\n\n    compose_value(value, coords) {\n      if (!value || !value.reduce) return '';\n      return value.reduce((result, val) => {\n        switch (val.type) {\n          case 'text': {\n            result += val.value;\n            break;\n          }\n          case 'func': {\n            let fname = val.name.substr(1);\n            let fn = this.pick_func(fname);\n            if (fn) {\n              coords.position = val.position;\n              let args = val.arguments.map(arg => {\n                if (fn.lazy) {\n                  return idx => this.compose_argument(arg, coords, idx);\n                } else {\n                  return this.compose_argument(arg, coords);\n                }\n              });\n              result += apply_args(fn, coords, args);\n            }\n          }\n        }\n        return result;\n      }, '');\n    }\n\n    compose_rule(token, _coords, selector) {\n      let coords = Object.assign({}, _coords);\n      let prop = token.property;\n      let value_group = token.value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords);\n        if (composed) ret.push(composed);\n        return ret;\n      }, []);\n\n      let value = value_group.join(', ');\n\n      if (/^animation(\\-name)?$/.test(prop)) {\n        this.props.has_animation = true;\n        if (coords.count > 1) {\n          let { count } = coords;\n          switch (prop) {\n            case 'animation-name': {\n              value = value_group\n                .map(n => this.compose_aname(n, count))\n                .join(', ');\n              break;\n            }\n            case 'animation': {\n              value = value_group\n                .map(n => {\n                  let group = (n || '').split(/\\s+/);\n                  group[0] = this.compose_aname(group[0], count);\n                  return group.join(' ');\n                })\n                .join(', ');\n            }\n          }\n        }\n      }\n\n      if (prop == 'content') {\n        if (!/[\"']|^none$|^(var|counter|counters|attr)\\(/.test(value)) {\n          value = `'${ value }'`;\n        }\n      }\n\n      if (prop == 'transition') {\n        this.props.has_transition = true;\n      }\n\n      let rule = `${ prop }: ${ value };`;\n      rule = prefixer(prop, rule);\n\n      if (prop == 'clip-path') {\n        // fix clip bug\n        rule += ';overflow: hidden;';\n      }\n\n      if (prop == 'width' || prop == 'height') {\n        if (!is_special_selector(selector)) {\n          rule += `--internal-cell-${ prop }: ${ value };`;\n        }\n      }\n\n      if (Property[prop]) {\n        let transformed = Property[prop](value, {\n          is_special_selector: is_special_selector(selector)\n        });\n        switch (prop) {\n          case '@grid': {\n            if (is_host_selector(selector)) {\n              this.grid = transformed.grid;\n              rule = transformed.size || '';\n            }\n            break;\n          }\n          case '@place-cell': {\n            if (!is_host_selector(selector)) {\n              rule = transformed;\n            }\n          }\n          case '@use': {\n            if (token.value.length) {\n              this.compose(coords, token.value);\n            }\n            rule = Property[prop](token.value);\n          }\n          default: {\n            rule = transformed;\n          }\n        }\n      }\n\n      return rule;\n    }\n\n    compose(coords, tokens) {\n      this.coords.push(coords);\n      (tokens || this.tokens).forEach((token, i) => {\n        if (token.skip) return false;\n        switch (token.type) {\n          case 'rule':\n            this.add_rule(\n              this.compose_selector(coords.count),\n              this.compose_rule(token, coords)\n            );\n            break;\n\n          case 'pseudo': {\n            if (token.selector.startsWith(':doodle')) {\n              token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n            }\n            let special = is_special_selector(token.selector);\n            if (special) {\n              token.skip = true;\n            }\n            token.selector.split(',').forEach(selector => {\n              let pseudo = token.styles.map(s =>\n                this.compose_rule(s, coords, selector)\n              );\n              let composed = special\n                ? selector\n                : this.compose_selector(coords.count, selector);\n              this.add_rule(composed, pseudo);\n            });\n\n            break;\n          }\n\n          case 'cond': {\n            let fn = Selector[token.name.substr(1)];\n            if (fn) {\n              let args = token.arguments.map(arg => {\n                return this.compose_argument(arg, coords);\n              });\n              let result = apply_args(fn, coords, args);\n              if (result) {\n                this.compose(coords, token.styles);\n              }\n            }\n            break;\n          }\n\n          case 'keyframes': {\n            if (!this.keyframes[token.name]) {\n              this.keyframes[token.name] = coords => `\n              ${ join(token.steps.map(step => `\n                ${ step.name } {\n                  ${ join(\n                    step.styles.map(s => this.compose_rule(s, coords))\n                  )}\n                }\n              `)) }\n            `;\n            }\n          }\n        }\n      });\n    }\n\n    output() {\n      Object.keys(this.rules).forEach((selector, i) => {\n        if (is_parent_selector(selector)) {\n          this.styles.container += `\n          .container {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        } else {\n          let target = is_host_selector(selector) ? 'host' : 'cells';\n          this.styles[target] += `\n          ${ selector } {\n            ${ join(this.rules[selector]) }\n          }\n        `;\n        }\n      });\n\n      let keyframes = Object.keys(this.keyframes);\n      this.coords.forEach((coords, i) => {\n        keyframes.forEach(name => {\n          let aname = this.compose_aname(name, coords.count);\n          this.styles.keyframes += `\n          ${ maybe(i == 0,\n            `@keyframes ${ name } {\n              ${ this.keyframes[name](coords) }\n            }`\n          )}\n          @keyframes ${ aname } {\n            ${ this.keyframes[name](coords) }\n          }\n        `;\n        });\n      });\n\n      return {\n        props: this.props,\n        styles: this.styles,\n        grid: this.grid\n      }\n    }\n  }\n\n  function generator(tokens, grid_size) {\n    let rules = new Rules(tokens);\n    let context = {};\n    rules.compose({\n      x : 1, y: 1, count: 1, context: {},\n      grid: { x : 1, y: 1, count: 1 }\n    });\n    let { grid } = rules.output();\n    if (grid) grid_size = grid;\n    rules.reset();\n\n    for (let x = 1, count = 0; x <= grid_size.x; ++x) {\n      for (let y = 1; y <= grid_size.y; ++y) {\n        rules.compose({ x, y, count: ++count, grid: grid_size, context });\n      }\n    }\n    return rules.output();\n  }\n\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({ mode: 'open' });\n      this.extra = {\n        get_custom_property_value: this.get_custom_property_value.bind(this)\n      };\n    }\n    connectedCallback() {\n      setTimeout(() => {\n        let compiled;\n        let use = this.getAttribute('use') || '';\n        if (use) use = `@use:${ use };`;\n        if (!this.innerHTML.trim() && !use) return false;\n        try {\n          let parsed = parse$1(use + this.innerHTML, this.extra);\n          this.grid_size = parse_grid(this.getAttribute('grid'));\n          compiled = generator(parsed, this.grid_size);\n          compiled.grid && (this.grid_size = compiled.grid);\n          this.build_grid(compiled);\n        } catch (e) {\n          this.innerHTML = '';\n          console.error(e && e.message || 'Error in css-doodle.');\n        }\n      });\n    }\n\n    get_custom_property_value(name) {\n      return getComputedStyle(this).getPropertyValue(name)\n        .trim()\n        .replace(/^\\(|\\)$/g, '');\n    }\n\n    build_grid(compiled) {\n      const { has_transition, has_animation } = compiled.props;\n      const { keyframes, host, container, cells } = compiled.styles;\n\n      this.doodle.innerHTML = `\n      <style>\n        ${ this.style_basic() }\n      </style>\n      <style class=\"style-keyframes\">\n        ${ keyframes }\n      </style>\n      <style class=\"style-container\">\n        ${ this.style_size() }\n        ${ host }\n        ${ container }\n      </style>\n      <style class=\"style-cells\">\n        ${ (has_transition || has_animation) ? '' : cells }\n      </style>\n      <div class=\"container\">\n        ${ this.html_cells() }\n      </div>\n    `;\n\n      if (has_transition || has_animation) {\n        setTimeout(() => {\n          this.set_style('.style-cells', cells);\n        }, 50);\n      }\n    }\n\n    inherit_props(p) {\n      return get_props(/grid/)\n        .map(n => `${ n }: inherit;`).join('');\n    }\n\n    style_basic() {\n      return `\n      :host {\n        display: block;\n        visibility: visible;\n        width: 1em;\n        height: 1em;\n      }\n      .container, [cell]:not(:empty) {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        display: grid;\n        ${ this.inherit_props() }\n      }\n      [cell]:empty {\n        position: relative;\n        line-height: 1;\n        box-sizing: border-box;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n    `;\n    }\n\n    style_size() {\n      let { x, y } = this.grid_size;\n      return `\n      :host {\n        grid-template-rows: repeat(${ x }, 1fr);\n        grid-template-columns: repeat(${ y }, 1fr);\n      }\n    `;\n    }\n\n    html_cells() {\n      let block = '<div cell></div>';\n      let cells = block.repeat(this.grid_size.count);\n      let depth = this.grid_size.z;\n\n      while (depth--) {\n        block = block.replace(/<div\\scell><\\/div>/g,\n          '<div cell>' + cells + '</div>'\n        );\n      }\n      return block.replace(/^<div\\scell>|<\\/div>$/g, '')\n    }\n\n    set_style(selector, styles) {\n      const el = this.shadowRoot.querySelector(selector);\n      el && (el.styleSheet\n        ? (el.styleSheet.cssText = styles )\n        : (el.innerHTML = styles));\n    }\n\n    update(styles) {\n      let use = this.getAttribute('use') || '';\n      if (use) use = `@use:${ use };`;\n\n      if (!styles) styles = this.innerHTML;\n      this.innerHTML = styles;\n\n      if (!this.grid_size) {\n        this.grid_size = parse_grid(this.getAttribute('grid'));\n      }\n\n      const compiled = generator(parse$1(use + styles, this.extra), this.grid_size);\n\n      if (compiled.grid) {\n        let { x, y, z } = compiled.grid;\n        let { x: gx, y: gy, z: gz } = this.grid_size;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, compiled.grid);\n          return this.build_grid(compiled);\n        }\n        Object.assign(this.grid_size, compiled.grid);\n      }\n\n      else {\n        let grid = parse_grid(this.getAttribute('grid'));\n        let { x, y, z } = grid;\n        let { x: gx, y: gy, z: gz } = this.grid_size;\n        if (gx !== x || gy !== y || gz !== z) {\n          Object.assign(this.grid_size, grid);\n          return this.build_grid(\n            generator(parse$1(use + styles, this.extra), this.grid_size)\n          );\n        }\n      }\n\n      this.set_style('.style-keyframes',\n        compiled.styles.keyframes\n      );\n      this.set_style('.style-container',\n          this.style_size()\n        + compiled.styles.host\n        + compiled.styles.container\n      );\n      this.set_style('.style-cells',\n        compiled.styles.cells\n      );\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.setAttribute('grid', grid);\n      this.connectedCallback();\n    }\n\n    get use() {\n      return this.getAttribute('use');\n    }\n\n    set use(use) {\n      this.setAttribute('use', use);\n      this.connectedCallback();\n    }\n\n    static get observedAttributes() {\n      return ['grid', 'use'];\n    }\n\n    attributeChangedCallback(name, old_val, new_val) {\n      if (old_val == new_val) {\n        return false;\n      }\n      if (name == 'grid' && old_val) {\n        this.grid = new_val;\n      }\n      if (name == 'use' && old_val) {\n        this.use = new_val;\n      }\n    }\n  }\n\n  customElements.define('css-doodle', Doodle);\n\n}));\n"],"sourceRoot":""}